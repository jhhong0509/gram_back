# 자바에 대하여
- 자바의 기원
    - 자바는 1995년 썬 마이크로 시스템즈에서 가전제품을 목적으로 해서 Oak라는 이름으로 발표되었다.
    - 점점 발전하며 인터넷 프로그래밍 언어가 되어 자바라는 이름을 갖게 되었다.
    - 자바는 처음부터 객체지향 개발을 위해 설계되었다.
- 자바의 장점
    - 자바는 이식성이 높아 class 파일은 맥, 윈도우, 리눅스 등 아무데서나 돌릴 수 있고, JVM은 많은 운영체제에서 지원된다.
    - 메모리를 자동으로 지원한다.
    - 함수적 스타일 코딩을 지원한다.
    - 앱, 웹, 서버 등 많은 분야에서 사용된다.
    - 멀티 쓰레드를 쉽게 구현할 수 있고, 어느 운영체제에서도 사용할 수 있다
        - 멀티쓰레드란, 여러 쓰레드를 통해 병렬로 처리할 수 있는 기능이다.
    - 동적 로딩을 지원한다.
        - 동적 로딩이란 미리 객체를 만들지 않고 필요한 시점에 동적으로 로딩할 수 있는 기능이다.
        - 그렇기 때문에 유지보수를 할 때 수정할 객체만 수정/교체 하는것이 용이하다.
    - 많은 오픈소스 라이브러리를 지원한다.
        - 자바는 오픈소스 언어이기 때문에 다른 라이브러리도 대부분 오픈소스이다. 그래서 이 오픈소스를 사용하면 노력, 시간, 비용을 줄이고 유지보수를 편리하게 할 수 있다.
- 자바 에디션
    - Java SE
        - Java Standard Edition의 약자로, 자바 프로그램이 공통으로 사용하는 API, 개발도구로 다른 에디션의 기초라 생각하면 된다.
        - 사용을 위해 JDK가 필요하다.
    - Java EE
        - Java Enterprise Edition의 약자로, 웹, 분산 컴퍼넌트를 위한 개발도구와 API가 있으며 목적에 따라 WAS, Tomcat, WebLogic, Jeus 등을 필요로 한다.
    - Java ME
        - Java Micro Edition의 약자로, 인베디드(으으..)와 모바일 장비 개발을 위한 API와 개발도구가 있다
- 자바 개발환경
    - JVM은 Java Virtual Machine의 약자로, 자바 프로그램을 실행시켜주는 놈이다.
    - JRE는 Java Runtime Environment의 약자로, JVM + 표준 클래스 라이브러리이다.
    - JDK는 JRE+개발도구이다.
 # 자바 컴파일
- 컴파일 과정
    - 우리가 아는 프로그래밍 언어(.java)를 바이트 코드 파일(.class)로 변환해 준다.
    - 변환된 바이트 코드 파일(.class)를 자바 가상 머신을 통해 기계어로 컴파일 해 준다.
    - JVM은 운영체제마다 각각 있어서 설치하고 JVM에 .class를 넣어주면 운영체제에 맞는 언어로 JVM이 바꿔준다.
- 실제 자바 파일 실행법
    - cmd에서 cd를 통해 자신의 자바 코드가 있는 위치로 가 준다.
    - javac 파일명.java 를 통해 소스파일을 .class 파일로 변환해 준다.
    - 그 후에 java 파일명.class를 통해 .class 파일을 실행시켜준다.
# 주석
- 한줄 주석
    - //를 통해 할 수 있다.
- 여러줄 주석
    - /* 주석 내애용 */을 통해 여러줄 주석을 할 수 있다.
    - /** 주석 내애애용 */도큐먼트 주석을 사용할섹 수 있다고 하는데, 뭔지 모르겠다..
# 변수
- 변수란
    - 변수란 데이터를 저장하는 메모리 공간을 말한다.
    - 변수는 변수를 특정하는 이름을 가지고, 하나의 변수는 하나의 값만 저장할 수 있다.(배열은 변수를 여러개 만ㄴ든 것 이므로, 하나의 변수에는 하나의 값만 들어간다.)
- 변수의 선언과 사용
    - 변수의 선언
        - 변수는 자료형 변수이름 을 통해 선언할 수 있다.
        - 변수를 선언할 때엔 ,를 통해 여러개를 한번에 선언할 수 있다.
        - 하나의 변수는 하나의 자료형만 저장할 수 있다.
        - 변수 이름 규칙(필수)
            - 첫글자는 문자, '$', '_'중 하나여야 한다.
            - 대소문자는 구분된다.
            - 문자 길이의 제한은 없다.
            - 예약어(이미 자바에서 사용중인 이름)은 사용할 수 없다.
        - 변수 이름 규칙(관례)
            - 첫문자는 영어 소문자로 하고, 여러 단어를 붙일 때엔 두번째 단어부터 첫 글자를 대문자로 한다.
            - 한글은 사용하지 않는다.
    - 변수의 사용
        - 값 저장
            - 변수를 사용할 때엔 대입연산자 '='을 통해 값을 저장한다.
            - 변수의 값을 처음 저장하는걸 초깃값 이라고 하고, 대입연산자를 이용해 변수에 값을 넣는게초기화 라고 한다.
        - 리터럴
            - 변수, 상수에 저장되는 값
        - 사용 범위
            - 변수는 선언된 스코프 내에서만 사용 가능하다.
                - 스코프란  
                if (true)  
                {여어기}  
                에서 여어기 처럼 하나의 중괄호 안의 범위이다.
# 기본 자료형
- 정수
    - byte
        - byte타입은 1바이트의 메모리를 사용하며,
        - 이미지나 파일 등을 처리할 때 사용되는 2진 데이터를 처리할 때 사용된다.
        - 범위는 -128 ~ 127이다.
    - char
        - char 변수에는 '로 감싸진 문자가 들어가면 자동으로 문자에 맞는 유니코드가 들어간다.
        - 범위는 \u0000 ~ \uFFFF라고 한다.
    - short
        - 2바이트로 표현되는 데이터 타입.
        - 범위는 -32768 ~ 32767
        - 잘 안쓴다.
    - int
        - 4바이틏에 표현되는 데이터 타입.
        - 자바에서 정수를 위한 기본 연산이다.
        - 리터럴(값)을 대입할 때 0x를 붙이면 16진수, O를 붙이면 8진수가 된다.
        - 범위는 -2147483648 ~ 2147483647
    - long
        - 8바이트로 표현되는 데이터 타입
        - 정수 뒤에 L을 통해 Long 타입을 알려준다.
        - 범위는 -9223372036854775808 ~ 9223372036854775807 이다
    - 실수
        - float
            - float는 소수 8번째까지 저장할 수 있다.
            - java는 기본이 double이기 때문에 float를 사용하기 위해선 뒤에 f를 붙여야 한다.
        - double
            - double은 소수점 16자리까지 저장할 수 있다.
    - 논리
        - boolean
            - 자바의 true, false를 저장할 수 있다.
# 타입 변환
- 자동 타입변환
    - 자동 타입 변환은 자동으로 메모리 크기가 작은 타입 -> 메모리 크기가 큰 타입으로 바뀌는 것이다.
    - 값의 손실이 없다.
    - 예외로 byte는 음수가 있지만 char에는 음수가 없어 자동 타입 변환을 할 수 없다.
- 강제 타입 변환
    - 강제 타입 변환은 메모리 크기가 큰 타입 -> 메모리 크기가 작은 타입으로 변환시켜주는 것을 말한다.
    - 값의 손실이 있다.
    - 예제
        - float a를 int b에 넣는다면 b = (int)a 처럼 할 수 있다.
        - 여기서 만약 a가 12.34라면, b는 정수형이기 때문에 정수만 받아와서 12가 된다.
# 연산자, 연산식
- 1항 
    - 부호
        - +
            - 변수/숫자 앞에 +를 붙이면 부호가 +가 된다.
        - -
            - 변수/숫자 앞에 -를 붙이면 부호가 -가 된다.
    - 증감
        - ++
            - 값이 1만큼 증가하는 연산자. 앞에 붙이는 것 과 뒤에 붙이는 것 이 다르다.
        - \-\-
            - 값이 1만큼 감소하는 연산자. 앞에 붙이는 것 과 뒤에 붙이는 것 이 다르다.
    - 비트
        - ~
            - ~연산자는 NOT 연산자 이다.
            - 각각의 비트를 1은 0으로, 0은 1로 바꿔준다.
    - 논리
        - !
            - !연산자는 true는 false를, false 는 true를 반환한다.
- 2항
    - 비트
        - &
            - &연산자는 AND 연산자이다.
            - 두 비트 모두 1일 때 1을 반환한다.
        - |
            - |연산자는 OR 연산자이다.
            - 두 비트중 하나가 1일 때 1을 반환한다.
        - ^
            - ^연산자는 XOR 연산자이다.
            - 두 비트가 서로 다를 경우에만 1을 반환한다.
    - 논리
        - &
            - 둘 다 true일때만 true를 반환한다.
            - 만약 false가 나와도 계속 연산을 수행한다.
        - &&
            - 둘 다 true일때만 true를 반환한다.
            - 만약 false가 나오면 연산을 중단한다.
        - |
            - 둘중 하나라도 true일때 true를 반환한다.
            - 만약 true가 나와도 계속 연산을 수행한다.
        - ||
            - 둘중 하나라도 true일때 true를 반환한다.
            - 만약 true 나오면 연산을 중단한다.
    - 비교
        - ==
            - 만약 두 값이 같으면 true를 반환한다.
        - !=
            - 만약 두 값이 다르면 true를 반환한다.
        - \>
            - 만약 왼쪽이 더 크면 true를 반환한다.
        - \>
            - 만약 오른쪽이 더 크면 true를 반환한다.
        - \>=
            - 만약 왼쪽이 더 크거나 같으면 true를 반환한다.
        - \<=
            - 만약 오른쪽이 더 크거나 같으면 true를 반환한다.
    - 쉬프트
        - <<
            - 좌항의 각 비트를 우항만큼 왼쪽으로 이동시킨다.
            - 빈자리는 0으로 채운다.
        - \>\>
            - 좌항의 각 비트를 우항만큼 이동시킨다.
        - \>\>\>
            - 좌항의 각 비트를 우항만큼 이동시킨다.
            - 빈자리는 0으로 채워진다.
    - 산술
        - \+
            - 좌항과 우항의 더한 값을 반환한다.
        - \-
            - 좌항과 우항을 뺀 값을 반환한다.
        - \*
            - 좌항과 우항을 곱한 값을 반환한다.
        - /
            - 좌항과 우항을 나눈 몫을 반환한다.
        - %
            - 좌항과 우항을 나눈 나머지를 반환한다.
    - 문자열
        - \+
            - 좌항의 문자열과 우항의 문자열을 합친 문자열을 반환한다.
        - 대입
            - =
                - 좌항의 변수에 우항의 값을 넣는다.
            - +=
                - 좌항의 변수에 우항의 값을 더해서 넣는다.
            - -=
                - 좌항의 변수에 우항의 값을 빼서 넣는다.
            - *=
                - 좌항의 변수에 우항의 값을 곱해서 넣는다.
            - /=
                - 좌항의 변수에 우항의 값을 나눈 몫을 넣는다.
            - %=
                - 좌항의 변수에 우항의 값을 나눈 나머지를 넣는다.
            - &=
                - 좌항과 우항을 AND 연산을 한 값을 좌항에 넣는다.
            - |=
                - 좌항과 우항을 OR 연산을 한 값을 좌항에 넣는다.
            - ^=
                - 좌항과 우항을 XOR 연산을 한 값을 좌항에 넣는다.
            - <<=
                - 좌항을 왼쪽으로 우항만큼 쉬프트 연산을 한 값을 좌항에 넣는다.
            - \>\>=
                - 좌항을 오른쪽으로 우항만큼 쉬프트 연산을 한 값을 좌항에 넣는다.
            - \>\>\>=
                - 좌항을 오른쪽으로 부호에 상관 없이 우항만큼 쉬프트 연산을 한 값을 좌항에 넣는다.
- 3항
    - ?:
        - 조건식?값1:값2 처럼 사용할 수 있다.
        - 만약 조건식이 true라면 값1의 값이 반환되고, false라면 값2의 값이 반환된다.
# 조건문 / 반복문
- break, continue
    - break
        - break;은 하나의 반복문/조건문을 탈출한다.
        - 만약 여러개를 탈출하고 싶다면, aa: while(조건) 처럼 라벨을 달아줬을 때, break aa;처럼 break 라벨; 로 사용할 수 있다.
    - continue
        - 반복문에서 continue가 있다면 continue 뒤의 실행문은 무시하고 다시 반복문을 실행시킨다.
        - for문이라면 변수 증감은 실행된다.
- 조건문
    - if
        - if(조건){실행문} 으로 사용할 수 있다.
        - 조건이 true일 때 실행된다.
        - 실행문이 한줄 일 때 중괄호를 생략할 수 있지만, 추천하지는 않는다.
    - else if
        - if의 실행문 밑에서 else if(조건){실행문} 으로 사용할 수 있다.
        - 위의 조건문이 false이고, else if의 조건문이 true일 때 실행된다.
        - else if는 여러개 들어올 수 있다.
        - 계속 내려오면서 위가 false고 else if구문이 true이면 else if를 실행하고 탈출한다.
    - else
        - 만약 위의 모든 if, else if문을 돈 후에 하나도 true가 없었다면 실행된다.
        - 생략할 수 있다.
    - switch
        - switch(변수) {  
            case 값1:  
            &nbsp;&nbsp;&nbsp;&nbsp; 실행문;  
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;  
        }  
        처럼 사용할 수 있다.
        - switch의 변수의 값이 case 뒤의 값이라면 실행문을 실행한다.
        - if문과 다르게 1<변수 처럼 조건문을 사용할 수 없다.
        - case 맨 뒤에는 꼭 break;를 붙여야 한다. 아니면 case 값1을 실행한 후에, 그 뒤의 모든 case를 조건 확인 없이 실행한다.
- 반복문
    - for
        - for(변수 초기화; 조건; 변수 증감) {실행문;}
        - 조건이 true인동안 실행문을 실행한다.
        - 매 for문 마다 변수 증감 부분이 실행된다.
        - 변수 초기화는 처음 한번만 실행된다.
        - 비워놔도 무방하다.
    - while
        - while(조건문) {실행문;}
        - 조건문이 true인동안 계속해서 실행한다.
    - do {실행문} while(조건문);
        - while문과 같지만, 처음부터 조건이 false라도 최소한 한번은 실행한다.
# 참조 타입
- 참조타입이란
    - 참조타입이란 실제 값이 저장되는 것이 아니라, 값이 저장된 주소를 저장한다.
    - 참조타입에는 배열, 열거, 클래스, 인터페이스가 있다.
- 자바의 메모리 사용
    - 메소드
        - .class파일들을 클래스 로더로 읽는다.
        - 클래스별 코드를 분류해서 저장한다.
    - 힙
        - 객체, 배열이 생성되는 영역이다.
        - 참조되는 변수나 필드가 없는 객체는 쓰래기로 판단해서 쓰래기 객체는 자동으로 삭제한다.
    - JVM 스택 영역
        - 스레드마다 존재한다.
        - 스레드가 시작할 때 할당된다.
        - 메소드 호출을 할 때에 JVM 스택 안에 Frame을 추가한다.
        - 메소드 종료를 할 때 해당 Frame을 삭제한다.
- 연산자
    - 참조타입에서 ==은 참조하는 객체가 같은지 비교한다.
- null, NullPointerException
    - heap 영역의 변수를 참조하지 않으면 null값을 갖는다.
    - 값이 null인 참조변수를 쓰면 NullPointerException이 발생한다.
- String
    - 문자열을 저장하는 타입이다.
    - 같은 문자열을 string에 넣으면 같은 객체를 바라본다.
    - 하지만 new 연산으로 새로운 객체를 생성했다면 다른 객체를 바라본다.
    - .equals() 메소드
        - 문자열 내용 그 자체를 비교해주는 메소드
        - 문자열1.equals(문자열2)처럼 사용할 수 있다.
- 배열
    - 타입 변수[]; 처럼 사용할 수 있다.
    - 초기화를 할 때엔 new 연산자를 이용한다.
    - new 타입[] {값1,값2}처럼 초기화 할 수 있다.
        - 이 방식을 사용하면 값의 개수만큼 배열의 크기가 정해진다.
    - new 타입[배열 크기] 처럼 선언할 수 있다.
        - 이 때에는 각 타입마다의 초기값이 들어간다.
    - length
        - 배열.length를 하면 배열의 개수를 반환한다.
    - 다차원 배열
        - 타입 변수[][] = new 타입[행][열] 처럼 사용할 수 있다.
    - 배열 복사
        1. for문 으로 일일이 복사
        2. System.arraycopy 메소드 호출
        3. 얕은 복사
        4. 깊은 복사
    - 배열과 for문
        - for(타입 변수:배열) {
            실행문
        }
        - 위처럼 사용하면 for문 마다 배열의 각 요소를 꺼내서 변수에 넣는다.
- String[] args
    - 우리가 항상 자바 main 함수를 만들 때 보였던 String[] args란 cmd에서 자바를 실행할 때에 java 클래스.class였는데, 그 뒤에 값1, 값2를 해 주면 args 배열에 값을 넣을 수 있다.
- 열거 타입
    - enum 이름 {값1,값2...};
    - 상수중에 없는 값이 들어가려 하면 오류가 난다.
    - name()
        - name()은 열거 객체의 문자열을 반환
    - ordinal()
        - ordinal() 은 인덱스를 반환
    - compareTo()
        - 열거 객체를 비교해서 차이를 반환
    - values()
        - 모든 객체를 배열로 반환
# OOP
- OOP란
    - Object Oriented Programming의 약자로, 객체를 만들어서 그걸 조립해서 프로그램을 만드는 방법이다.
- 객체
    - 메소드
        - 객체에서의 동작
    - 필드
        - 객체에서의 속성
- 클래스
    - 객체를 만드는 설계도
    - API 클래스
    - main 메소드 제공
    - 구성
        - 필드
            - 변수와 비슷하지만 차이가 있다.
            - 메소드 실행 종료시 없어지는 변수와 달리 필드는 객체가 소멸될 때 없어진다.
        - 생성자
            - new 연산자로 호출되는 블록
            - 객체 생성할 때 초기화를 한다.
            - 우리가 선언해 주지 않아도 자동으로 생성됨
            - 클래스(매개변수) {객체 초기화}
            - 리턴 타입이 없음
            - 매개변수는 있어도 되고 없어도 됨
            - 생성자 오버로딩
                - 한 객체에 여러 생성자를 선언할 수 있도록 해줌
        - 메서드
            - 객체의 동작 부분
            - 리턴타입 메소드이름() {실행문}
            - 중괄호의 이름 = 메소드 이름
            - 외부에서 매개값을 입력받고, 반환 값을 줄 수 있다.
            - return 이후의 코드는 실행되지 않음
            - 매개변수의 개수를 모르면 배열타입으로 가능
            - 매개변수의 개수를 모를 때 ...을 통해 더 쉽게 사용할 수 있다.
            - 객체 외부와 내부의 호출이 다르다.
            - 한 클래스 안에 같은 이름의 메소드를 여러개 선언할 수 있다.
    - 이름 규칙
        - 하나 이상의 문자로 구성
        - $, _를 제외한 특수문자 불가능
        - 예약어 사용 불가
        - 첫글자 대문자
- 인스턴스
    - 클래스로 만들어진 객체
- 특징
    - 캡슐화
        - 필드와 메소드를 비슷한 것 끼리 묶은 것
        - 묶여진 각각의 필드와 메소드를 외부에서 사용하지 못하도록 한다.
    - 상속
        - 상위 객체의 필드와 메소드를 상속받은 객체에서도 사용할 수 있도록 하는 것
    - 다형성
        - 같은 타입이라도 실행결과가 다양한 객체를 이용할 수 있는 성질
- 오버로딩, 오버라이딩
    - 오버로딩
        - 함수 이름이 같아도 매개변수가 다르면 함수를 생성할 수 있다.
        - 호출할 때 매개변수가 맞는 함수가 실행된다.
    - 오버라이딩
        - 하위 클래스에서 상위 클래스의 함수를 바꾸는 것이다(재정의)
- 클래스와 객체 문법
    - 인스턴스 멤버
        - 인스턴스 필드와 인스턴스 메소드를 합친 것이다.
        - 객체 생성 후 사용 가능
        - 자기 자신을 this라고 함.
    - 정적 멤버
        - 객체를 생성하지 않고 사용할 수 있다.
        - 한번 메모리에 할당되면 프로그램이 끝날때까지 없어지지 않아서 여러번 생성되지 않아 메모리를 아낄 수 있다.
    - 싱글톤
        - 하나만 생성된 객체
    - final
        - 자바에서 final이란 변하지 않는 값을 말한다.
        - final과 static final의 차이는 공용성에 있다.
        - final 타입 필드;
        - 이름은 대문자가 관례이다.
- 접근 제한자
    - public
        - 모든 클래스에서 접근 가능
    - protected
        - 같은 패키지 또는 자식 클래스에서만 접근할 수 있다.
    - default
        - 같은 패키지의 클래스에서만 접근할 수 있다.
        - 별다르게 선언을 하지 않으면 default이다.
    - private
        - 같은 클래스에서만 접근이 가능하다.
- Getter, Setter
    - 객체 데이터를 외부에서 직접적으로 접근하는걸 막기 위해 메소드를 통해 간접적으로 접근하게 만든 것.
    - Getter은 객체의 데이터를 가져오는 메소드 이다.
    - 객체의 데이터를 변경하는 메소드 이다.
- 패키지
    - 클래스가 같아도 패키지가 다르면 다른 클래스로 인식
    - 패키지.패키지.클래스 처럼 .으로 구분
    - 윈도우의 폴더와 비슷하다고 생각하면 됨.
    - 이름 규칙
        - 첫글자 숫자, _, $를 제외한 특수문자 불가
        - java로 시작하는 패키지 불가
        - 모두 소문자가 관례
        - 도메인 역순으로 패키지
    - import
        - import 패키지.패키지.클래스
            - 해당 패키지의 클래스 하나를 불러옴
        - import 패키지.패키지.*
            - 해당 패키지의 모든 클래스를 불러옴
- 어노테이션
    - 어노테이션이란
        - 컴파일 할 때 실행 방법을 명시하는 것
    - 사용
        - public @interfface 어노테이션 이름 {정의}  
        @어노테이션 이름
        - 정의에는 타입 이름1(); 타입 이름2(); 처럼 괄호가 붙고, default가 사용 가능하다.
        - 이렇게 선언된 @interface는 @어노테이션 이름(값1,값2)처럼 사용할 수 있다.
# 상속
- 상속이란
    - 부모 클래스의  멤버를 자식 클래스에게 물려주는 것
    - 접근 제한자에 따라 모두 물려받지는 않는ㄴ다.
- 사용
    - class 선언 뒤에 extends 부모 처럼 사용할 수  있다.
    - 자바는 다중 상속을 사용할 수 없다.
    - 만약 명시하지 않았다면 컴파일러가 자식 생성자 맨 위에 부모 생성자를 호출한다.
    - 부모 생성자를 호출하려면 super()을 사용하면 된다.
    - 부모 클래스에 매개변수가 있다면 super(매개변수)로 호출해야 한다.
- 메소드 오버라이딩
    - 메소드 오버라이딩이란?
        - 부모 클래스의 메소드를 수정해서 사용하는걸 메소드 오버라이딩이라고 한다.
    - 규칙
        - 부모와 같은 리턴타입, 매개변수, 이름을 가져야 함
        - 접근 제한을 약하게는 할 수 있지만 강하게는 안됨
        - 예외처리를 추가할 수 없음
    - 오버라이딩 전 메소드 호출
        - super.부모의 메소드();
    - final
        - final을 붙이면 상속이나 오버라이딩이 불가능 하다.
- 다형성
    - 자동 타입 변환
        - 자식 객체를 부모 클래스의 변수에 넣으면 부모 객체로 자동 변환된다.
        - 해당 변수는 자식 객체를 참조한다.
    - 강제 타입 변환
        - 자동으로 부모 클래스의 객체로 바뀐 객체를 다시 자식 객체로 바꿀 수 있다.
- 추상
    - 추상 클래스
        - 특징
            - 클래스간의 특징을 추출해서 만든 클래스이다.
            - 추상 클래스는 부모 클래스로만 사용할 수 있다.
            - abstract class 클래스 이름
        - 목적
            - 클래스 이름 통일
            - 작성 시간 절약
            - 설계와 개발 분리
    추상 메소드
        - 사용
            - 접근 제한자 abstract 타입 메소드이름(매개변수);
        - 특징
            - 추상 클래스에서만 선언할 수 있다.
            - 중괄호가 없다.
            -반드시 재정의 되어야 한다.
# 인터페이스
- 인터페이스란
    - 객체의 사용법을 정의한 타입
- 사용
    - 접근 제한자 interface 이름{}처럼 사용할 수 있다.
- 구성
    - 상수 필드
        - 원래 데이터 저장 필드 선언이 불가능 하지만 상수 필드는 가능하다.
        - 초깃값이 필수
    - 추상 메소드
        - 객체의 접근 제한자와 매개변수와 리턴 타입, 이름만 정의해 준다.
    - default 메소드
        - 구현 객체가 가지고 있는 인스턴스 메소드
        - 인터페이스에 추상 메소드가 추가되면, 그 인터페이스의 모든 구현 클래스를 수정해야 하는데, 그걸 방지해 줌
        - 무조건 public
    - 정적 메소드
        - 인터페이스 만으로도 호출이 가능함
- 구현
    - 이미 만든 인터페이스와 똑같이 쓰되, implements 인터페이스를 붙여준다.
    - 다중 구현 또한 가능함.
- 익명 구현 객체
    - 사용 이유
        - 한번만 쓸 인터페이스를 클래스로 따로 구현을 하면 불필요 하기 때문에
    - 사용
        - 인터페이스이름 변수이름 = new 인터페이스이름() {실체 메소드)
- 구현 객체 사용
    - 인터페이스 변수 = 구현객체;
- 인터페이스 상속
    - public class 자식 implements 부모
# 중첩 클래스, 인터페이스
- 중첩 클래스
    - 의미
        - 클래스 안의 클래스
    - 특징
        - 각 멤버에 쉽게 접근할 수 있다.
        - 코드 복잡도 하락
    - 종류
        - 멤버 클래스
            - 의미
                - 외부 클래스의 멤버로 선언된 클래스
            - 인스턴스 멤버 클래스
                - static 없이 선언된 클래스
                - 인스턴스 멤버만 가능
                - 외부의 클래스의 모든 멤버 접근 가능
            - 정적 멤버 클래스
                - static 을 사용해서 생성된 클래스
                - 모든 종류의 멤버가 가능
                - 정적 멤버만 접근 가능
        - 로컬 클래스
            - 속해있는 메소드가 실행되어야 사용이 가능한 클래스
            - 인스턴스 멤버만 가능
                
- 중첩 인터페이스
    - 의미
        - 클래스 안의 인터페이스
    - 사용 이유
        - 해당 클래스와 관계를 맺는 구현 클래스 생성을 위해
    - 구현
        -클래스 뒤에 implements 클래스.인터페이스
# 익명 객체
- 익명 객체란?
    - 클래스 상속이나 인터페이스 구현에서 만들 수 있는 이름이 없는 객체
- 사용되는 곳
    - 필드와 로컬변수의 초깃값 또는 매개변수의 인자로 대입됨.
    - 만약 초깃값으로만 사용된다면 익명 자식 객체를 활용할 수 있음.
- 익명 객체에서 외부 멤버 참조
    - 외부 클래스의 멤버는 제한없이 접근 가능
    - 속해있는 메소드의 매개변수나 로컬변수 참조 불가능
        - 익명객체에서 참조하는 매개변수와 로컬변수는 final 특성을 가짐.
# 예외 처리
- 예외와 에러
    - 에러
        - 응용프로그램 실행 오류가 발생하는 것.
        - 실행 불능
    - 예외
        - 예외란 개발자의 코딩이나 조작에서 발생하는 오류이다.
        - 실행 불능이지만, 예외처리를 통해 정상 실행 가능
- 예외 종류
    - 일반
        - 컴파일러 체크 예외
    - 실행
        - 컴파일 과정에서 예외 처리 코드를 검사하지 않는 예외
- 자바 예외의 특징
    - JVM은 RUNTIME ERROR가 났을 때 예외 클래스로 객체를 만듬.
    - 모든 예외 클래스는 java.lang.Exception에 담김
        - 실행 예외는 RuntimeException에 담김
- 예외 처리 코드
    - try{코드1} catch(예외클래스 e) {코드2} finally{코드3}
    - 코드 해석
        - 위 코드는 우선 코드1을 실행하는데, 실행중 예외클래스의 예외가 발생한다면, 예외의 정보를 e에 담고 코드2를 실행함.
        - 코드3은 항상 실행됨.
    - 특징
        - try 뒤의 catch가 여러개가 올 수 있음
        - 예외클래스를 여러개 줄 수 있음.
        - 만약 throws를 사용하면 예외처리를 메소드를 호출한 곳에 넘겨줄 수 있다.
- 사용자 정의 예외
    - 표준 API에 없는 예외가 필요할 때 사용
# 기본 API 클래스
- 기본 API 클래스란?
    - 자바에서 제공하는 API
- 주로 쓰이는 것
    - java.lang
        - 기본적으로 사용 가능해서 import 필요 x
        - 간략한 용도
    - java.util
        - 배열조작, 날짜, 문자열 추출 등 많은 일을 함.
# 여러 클래스 정리
- Object
    - 모든 클래스의 부모 클래스.
    - 상속하지 않아도 알아서 상속
    - 모든 클래스에서 접근 가능
    - 메소드
        - equals()
            - 주소가 아닌 진짜 값을 비교함
        - hashCode()
            - 객체의 메모리를 이용해 해시코드를 만들어 줌.
        - toString
            - 객체를 문자열로 반환
        - clone()
            - 객체를 복제해준다.
        - finalize()
            - 객체 소멸자
            - 객체를 자동으로 소멸시킬 때 사용됨
###### 너무 많아... 다음에 시간 나면 해야지...
# 제네릭과 와일드카드
- 제네릭
    - 제네릭이란
        - 사용할 내부 타입을 외부에서 지정할 수 있게 해주는 것
    - 제네릭 클래스 사용
        - public class 이름<T,M,V>{}
        - 똑같이 인터페이스에도 가능
        - 각각의 대문자 알파벳 한글자는 각각의 타입을 의미함
        - 메소드를 사용할 떄는 메소드이름<타입> 이름 = new 이름<타입>(); 처럼 사용하면 된다.
        - 메소드 사용문에서 뒤쪽의 <타입>은 생략해도 된다.
    - 제네릭 메소드
        - 매개변수와 리턴타입을 타입 제네릭을 사용하는 메소드
        - 사용은 <타입>메소드(매개); 이거나 메소드(매개); 로 사용할 수 있다.
        - 1번째는 타입 매개변수를 명시해 주지만, 2번째는 매개값을 아마 그렇겠지처럼 추정한다.
    - 상위 클래스
        - T 대신 T extends 타입 을 사용하면 원하는 것 만 받을 수 있다.
        - extends에는 주로 Number처럼 상위 타입이 온다.
    - 사용이유
        - 제네릭 부분에서 오류가 나면 런타임에러가 아닌 제네릭 부분에서 컴파일 에러가 난다.
        - 불필요한 타입변환에서 나오는 낭비를 줄인다.
- 와일드 카드
    - 역할
        - 매개변수의 타입을 제한해 준다.
    - 사용법
        - 매개변수의 앞에 <?>처럼 붙이면 쓸 수 있다.
        - 만약 어떤 타입의 상위타입의 자손들만 사용할 수 있게 해주려면 <? extends T>처럼 사용하면 된다.
        - 만약 어떤 타입의 조상들만 사용할 수 있게 해주려면 <? super T>처럼 사용하면 된다.
# 람다식
- 람다식이란?
    - 익명함수를 생성해주는 식
- 사용
    - 매개변수 -> 코드
    - 매개변수 타입은 자동 인식
###### 선배가 알려주시겠지 ^^b 고로 14-1로 넘어감.
# 컬렉션 프레임워크
- 자바의 객체 처리
    - 자바는 여러개의 객체를 저장할 때 배열을 사용한다. 하지만 객체를 삭제했을 때 빈 공간이 생겨 문제가 생긴다.
- 컬렉션이란
    - 요소를 수집해서 저장하는 것
    - 자바의 컬렉션은 객체를 수집해서 저장한다.
- 컬렉션 프레임워크란
    - java.util에 있는 컬렉션과 관련된 인터페이스와 클래스를 말하는데, 몇몇 인터페이스를 통해 다양하게 이용할 수 있다.
    - 종류
        - List
            - 순서를 유지하면서 저장해 줌
            - 중복 가능
        - Set
            - 순서가 없음
            - 중복이 불가능
        - Map
            - 키:값 처럼 저장함
            - 키값은 중복이 불가능
- List
    - 메소드
        - boolean add
            - 맨 뒤에 객체 추가
        - void add
            - 해당 인덱스에 객체 추가
        - E set
            - 해당 인덱스의 객체를 주어진 객체로 바꿈.
        - boolean isEmpty
            - 자료구조시간에 한 것 처럼 비었는지 확인
        - int size
            - 객체 수 반환
        - void clear()
            - 컬렉션을 초기화
        - E remove
            - 해당 인덱스의 객체 삭제(인덱스를 매개변수로 줘서 해당 인덱스 삭제)
        - boolean remove
            - 컬렉션 객체 삭제(아마 객체 전체를 매개변수로 줘서 해당 객체를 찾아서 삭제)
    - ArrayList
        - 자료구조
            - 내부적 배열을 이용
            - 선형 리스트로, 배열이 가득 차면 새로 할당해줌
        - 장점
            - 요소 검색이 빠름
        - 단점
            - 삽입과 삭제가 오래걸림
    - Vector
        - 특징
            - ArrayList와 거의 비슷함
        - ArrayList와 다른점
            - 멀티스레드에서 스레드가 안전함
            - 무조건적으로 자동 동기화를 함
            - 성능이 딸림
    - LinkedList
        - 특징
            - 자료구조시간에 맨날 하던 그 연결리스트
            - 검색이 느림
            - 순차적으로 삽입과 삭제는 느리지만 중간에 삽입 삭제는 빠름
- Set
    - set이란
        - 수학의 집합과 비슷
    - 특징
        - 순서가 없음
        - 중복이 불가능
    - 메소드
        - boolean add
            - 저장
            - 성공, 실패를 반환
        - boolean contains
            - 해당 객체가 있는지 확인
            - ctrl+f 와 비슷
        - boolean isEmpty
            - List의 isEmpty처럼 비었는지 확인
        - Iterator iterator
            - 지정된 객체를 하나씩 가져오는 반복자 반환
        - int size
            - 객체의 개수를 반환
        - void clear
            - 컬렉션 지우기
        - boolean remove
            - 해당 객체를 지움
    - Iterator
        - 전체 객체를 한번에 하나씩 가져오는 반복자
        - boolean hasNext
            - 가져올 객체 있나 판별
        - E Next
            - 가져올 객체 있나 판별
        - void remove
            - next로 가져온 객체 제거
    - HashSet
        - 특징
            - 해시 알고리즘을 이용한 집합
            - 매우 빠름
            - 역시 순서 무시, 중복 불가
            - 해시 알고리즘을 사용
- Map
    - Map 컬렉션이란
        - 키와 값을 쌍으로 저장하는 구조
    - 특징
        - Collection 인터페이스와 다른 저장방식 사용
        - key는 값을 찾기 위한 역할
        - 순서따위 없다
        - key는 중복이 불가능하다
    - 메소드
        - V put
            - 키와 값을 저장함
            - 저장된 값 반환
        - boolean containsKey
            - 키가 있는지 확인
        - boolean containsValue
            - 컬렉션에 값이 있는지 확인
        - V get
            - 컬렉션 안에 키와 일치하는 값을 반환(contains key + 값 반환)
        - Set<Map.Entity<K,V>> entrySet
            - 모든 Entity 객체를 Set 컬렉션에 담아서 반환
        - Set keySey
            - 모든 키를 Set에 담아서 반환
        - Collection values
            - 모든 값을 Collection 컬렉션에 담아서 반환
        - boolean isEmpty
            - 어디에나 있는 비었는지 확인
        - int size
            - 키의 수 반환(값의 수랑 같겠지?)
        - void clear
            - 초기화ㅏ
        - V remove
            - 키와 일치하는 Map.Entry 삭제, 값 반환
    - 컬렉션 루핑