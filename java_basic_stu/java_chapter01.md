# 자바에 대하여
- 자바의 기원
    - 자바는 1995년 썬 마이크로 시스템즈에서 가전제품을 목적으로 해서 Oak라는 이름으로 발표되었다.
    - 점점 발전하며 인터넷 프로그래밍 언어가 되어 자바라는 이름을 갖게 되었다.
    - 자바는 처음부터 객체지향 개발을 위해 설계되었다.
- 자바의 장점
    - 자바는 이식성이 높아 class 파일은 맥, 윈도우, 리눅스 등 아무데서나 돌릴 수 있고, JVM은 많은 운영체제에서 지원된다.
    - 메모리를 자동으로 지원한다.
    - 함수적 스타일 코딩을 지원한다.
    - 앱, 웹, 서버 등 많은 분야에서 사용된다.
    - 멀티 쓰레드를 쉽게 구현할 수 있고, 어느 운영체제에서도 사용할 수 있다
        - 멀티쓰레드란, 여러 쓰레드를 통해 병렬로 처리할 수 있는 기능이다.
    - 동적 로딩을 지원한다.
        - 동적 로딩이란 미리 객체를 만들지 않고 필요한 시점에 동적으로 로딩할 수 있는 기능이다.
        - 그렇기 때문에 유지보수를 할 때 수정할 객체만 수정/교체 하는것이 용이하다.
    - 많은 오픈소스 라이브러리를 지원한다.
        - 자바는 오픈소스 언어이기 때문에 다른 라이브러리도 대부분 오픈소스이다. 그래서 이 오픈소스를 사용하면 노력, 시간, 비용을 줄이고 유지보수를 편리하게 할 수 있다.
- 자바 에디션
    - Java SE
        - Java Standard Edition의 약자로, 자바 프로그램이 공통으로 사용하는 API, 개발도구로 다른 에디션의 기초라 생각하면 된다.
        - 사용을 위해 JDK가 필요하다.
    - Java EE
        - Java Enterprise Edition의 약자로, 웹, 분산 컴퍼넌트를 위한 개발도구와 API가 있으며 목적에 따라 WAS, Tomcat, WebLogic, Jeus 등을 필요로 한다.
    - Java ME
        - Java Micro Edition의 약자로, 인베디드(으으..)와 모바일 장비 개발을 위한 API와 개발도구가 있다
- 자바 개발환경
    - JVM은 Java Virtual Machine의 약자로, 자바 프로그램을 실행시켜주는 놈이다.
    - JRE는 Java Runtime Environment의 약자로, JVM + 표준 클래스 라이브러리이다.
    - JDK는 JRE+개발도구이다.
 # 자바 컴파일
- 컴파일 과정
    - 우리가 아는 프로그래밍 언어(.java)를 바이트 코드 파일(.class)로 변환해 준다.
    - 변환된 바이트 코드 파일(.class)를 자바 가상 머신을 통해 기계어로 컴파일 해 준다.
    - JVM은 운영체제마다 각각 있어서 설치하고 JVM에 .class를 넣어주면 운영체제에 맞는 언어로 JVM이 바꿔준다.
- 실제 자바 파일 실행법
    - cmd에서 cd를 통해 자신의 자바 코드가 있는 위치로 가 준다.
    - javac 파일명.java 를 통해 소스파일을 .class 파일로 변환해 준다.
    - 그 후에 java 파일명.class를 통해 .class 파일을 실행시켜준다.
# 주석
- 한줄 주석
    - //를 통해 할 수 있다.
- 여러줄 주석
    - /* 주석 내애용 */을 통해 여러줄 주석을 할 수 있다.
    - /** 주석 내애애용 */도큐먼트 주석을 사용할섹 수 있다고 하는데, 뭔지 모르겠다..
# 변수
- 변수란
    - 변수란 데이터를 저장하는 메모리 공간을 말한다.
    - 변수는 변수를 특정하는 이름을 가지고, 하나의 변수는 하나의 값만 저장할 수 있다.(배열은 변수를 여러개 만ㄴ든 것 이므로, 하나의 변수에는 하나의 값만 들어간다.)
- 변수의 선언과 사용
    - 변수의 선언
        - 변수는 자료형 변수이름 을 통해 선언할 수 있다.
        - 변수를 선언할 때엔 ,를 통해 여러개를 한번에 선언할 수 있다.
        - 하나의 변수는 하나의 자료형만 저장할 수 있다.
        - 변수 이름 규칙(필수)
            - 첫글자는 문자, '$', '_'중 하나여야 한다.
            - 대소문자는 구분된다.
            - 문자 길이의 제한은 없다.
            - 예약어(이미 자바에서 사용중인 이름)은 사용할 수 없다.
        - 변수 이름 규칙(관례)
            - 첫문자는 영어 소문자로 하고, 여러 단어를 붙일 때엔 두번째 단어부터 첫 글자를 대문자로 한다.
            - 한글은 사용하지 않는다.
    - 변수의 사용
        - 값 저장
            - 변수를 사용할 때엔 대입연산자 '='을 통해 값을 저장한다.
            - 변수의 값을 처음 저장하는걸 초깃값 이라고 하고, 대입연산자를 이용해 변수에 값을 넣는게초기화 라고 한다.
        - 리터럴
            - 변수, 상수에 저장되는 값
        - 사용 범위
            - 변수는 선언된 스코프 내에서만 사용 가능하다.
                - 스코프란  
                if (true)  
                {여어기}  
                에서 여어기 처럼 하나의 중괄호 안의 범위이다.
# 기본 자료형
- 정수
    - byte
        - byte타입은 1바이트의 메모리를 사용하며,
        - 이미지나 파일 등을 처리할 때 사용되는 2진 데이터를 처리할 때 사용된다.
        - 범위는 -128 ~ 127이다.
    - char
        - char 변수에는 '로 감싸진 문자가 들어가면 자동으로 문자에 맞는 유니코드가 들어간다.
        - 범위는 \u0000 ~ \uFFFF라고 한다.
    - short
        - 2바이트로 표현되는 데이터 타입.
        - 범위는 -32768 ~ 32767
        - 잘 안쓴다.
    - int
        - 4바이틏에 표현되는 데이터 타입.
        - 자바에서 정수를 위한 기본 연산이다.
        - 리터럴(값)을 대입할 때 0x를 붙이면 16진수, O를 붙이면 8진수가 된다.
        - 범위는 -2147483648 ~ 2147483647
    - long
        - 8바이트로 표현되는 데이터 타입
        - 정수 뒤에 L을 통해 Long 타입을 알려준다.
        - 범위는 -9223372036854775808 ~ 9223372036854775807 이다
    - 실수
        - float
            - float는 소수 8번째까지 저장할 수 있다.
            - java는 기본이 double이기 때문에 float를 사용하기 위해선 뒤에 f를 붙여야 한다.
        - double
            - double은 소수점 16자리까지 저장할 수 있다.
    - 논리
        - boolean
            - 자바의 true, false를 저장할 수 있다.
# 타입 변환
- 자동 타입변환
    - 자동 타입 변환은 자동으로 메모리 크기가 작은 타입 -> 메모리 크기가 큰 타입으로 바뀌는 것이다.
    - 값의 손실이 없다.
    - 예외로 byte는 음수가 있지만 char에는 음수가 없어 자동 타입 변환을 할 수 없다.
- 강제 타입 변환
    - 강제 타입 변환은 메모리 크기가 큰 타입 -> 메모리 크기가 작은 타입으로 변환시켜주는 것을 말한다.
    - 값의 손실이 있다.
    - 예제
        - float a를 int b에 넣는다면 b = (int)a 처럼 할 수 있다.
        - 여기서 만약 a가 12.34라면, b는 정수형이기 때문에 정수만 받아와서 12가 된다.
# 연산자, 연산식
- 1항 
    - 부호
        - +
            - 변수/숫자 앞에 +를 붙이면 부호가 +가 된다.
        - -
            - 변수/숫자 앞에 -를 붙이면 부호가 -가 된다.
    - 증감
        - ++
            - 값이 1만큼 증가하는 연산자. 앞에 붙이는 것 과 뒤에 붙이는 것 이 다르다.
        - \-\-
            - 값이 1만큼 감소하는 연산자. 앞에 붙이는 것 과 뒤에 붙이는 것 이 다르다.
    - 비트
        - ~
            - ~연산자는 NOT 연산자 이다.
            - 각각의 비트를 1은 0으로, 0은 1로 바꿔준다.
    - 논리
        - !
            - !연산자는 true는 false를, false 는 true를 반환한다.
- 2항
    - 비트
        - &
            - &연산자는 AND 연산자이다.
            - 두 비트 모두 1일 때 1을 반환한다.
        - |
            - |연산자는 OR 연산자이다.
            - 두 비트중 하나가 1일 때 1을 반환한다.
        - ^
            - ^연산자는 XOR 연산자이다.
            - 두 비트가 서로 다를 경우에만 1을 반환한다.
    - 논리
        - &
            - 둘 다 true일때만 true를 반환한다.
            - 만약 false가 나와도 계속 연산을 수행한다.
        - &&
            - 둘 다 true일때만 true를 반환한다.
            - 만약 false가 나오면 연산을 중단한다.
        - |
            - 둘중 하나라도 true일때 true를 반환한다.
            - 만약 true가 나와도 계속 연산을 수행한다.
        - ||
            - 둘중 하나라도 true일때 true를 반환한다.
            - 만약 true 나오면 연산을 중단한다.
    - 비교
        - ==
            - 만약 두 값이 같으면 true를 반환한다.
        - !=
            - 만약 두 값이 다르면 true를 반환한다.
        - \>
            - 만약 왼쪽이 더 크면 true를 반환한다.
        - \>
            - 만약 오른쪽이 더 크면 true를 반환한다.
        - \>=
            - 만약 왼쪽이 더 크거나 같으면 true를 반환한다.
        - \<=
            - 만약 오른쪽이 더 크거나 같으면 true를 반환한다.
    - 쉬프트
        - <<
            - 좌항의 각 비트를 우항만큼 왼쪽으로 이동시킨다.
            - 빈자리는 0으로 채운다.
        - \>\>
            - 좌항의 각 비트를 우항만큼 이동시킨다.
        - \>\>\>
            - 좌항의 각 비트를 우항만큼 이동시킨다.
            - 빈자리는 0으로 채워진다.
    - 산술
        - \+
            - 좌항과 우항의 더한 값을 반환한다.
        - \-
            - 좌항과 우항을 뺀 값을 반환한다.
        - \*
            - 좌항과 우항을 곱한 값을 반환한다.
        - /
            - 좌항과 우항을 나눈 몫을 반환한다.
        - %
            - 좌항과 우항을 나눈 나머지를 반환한다.
    - 문자열
        - \+
            - 좌항의 문자열과 우항의 문자열을 합친 문자열을 반환한다.
        - 대입
            - =
                - 좌항의 변수에 우항의 값을 넣는다.
            - +=
                - 좌항의 변수에 우항의 값을 더해서 넣는다.
            - -=
                - 좌항의 변수에 우항의 값을 빼서 넣는다.
            - *=
                - 좌항의 변수에 우항의 값을 곱해서 넣는다.
            - /=
                - 좌항의 변수에 우항의 값을 나눈 몫을 넣는다.
            - %=
                - 좌항의 변수에 우항의 값을 나눈 나머지를 넣는다.
            - &=
                - 좌항과 우항을 AND 연산을 한 값을 좌항에 넣는다.
            - |=
                - 좌항과 우항을 OR 연산을 한 값을 좌항에 넣는다.
            - ^=
                - 좌항과 우항을 XOR 연산을 한 값을 좌항에 넣는다.
            - <<=
                - 좌항을 왼쪽으로 우항만큼 쉬프트 연산을 한 값을 좌항에 넣는다.
            - \>\>=
                - 좌항을 오른쪽으로 우항만큼 쉬프트 연산을 한 값을 좌항에 넣는다.
            - \>\>\>=
                - 좌항을 오른쪽으로 부호에 상관 없이 우항만큼 쉬프트 연산을 한 값을 좌항에 넣는다.
- 3항
    - ?:
        - 조건식?값1:값2 처럼 사용할 수 있다.
        - 만약 조건식이 true라면 값1의 값이 반환되고, false라면 값2의 값이 반환된다.
# 조건문 / 반복문
- break, continue
    - break
        - break;은 하나의 반복문/조건문을 탈출한다.
        - 만약 여러개를 탈출하고 싶다면, aa: while(조건) 처럼 라벨을 달아줬을 때, break aa;처럼 break 라벨; 로 사용할 수 있다.
    - continue
        - 반복문에서 continue가 있다면 continue 뒤의 실행문은 무시하고 다시 반복문을 실행시킨다.
        - for문이라면 변수 증감은 실행된다.
- 조건문
    - if
        - if(조건){실행문} 으로 사용할 수 있다.
        - 조건이 true일 때 실행된다.
        - 실행문이 한줄 일 때 중괄호를 생략할 수 있지만, 추천하지는 않는다.
    - else if
        - if의 실행문 밑ㅊ에서 else if(조건){실행문} 으로 사용할 수 있다.
        - 위의 조건문이 false이고, else if의 조건문이 true일 때 실행된다.
        - else if는 여러개 들어올 수 있다.
        - 계속 내려오면서 위가 false고 else if구문이 true이면 else if를 실행하고 탈출한다.
    - else
        - 만약 위의 모든 if, else if문을 돈 후에 하나도 true가 없었다면 실행된다.
        - 생략할 수 있다.
    - switch
        - switch(변수) {  
            case 값1:  
            &nbsp;&nbsp;&nbsp;&nbsp; 실행문;  
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;  
        }  
        처럼 사용할 수 있다.
        - switch의 변수의 값이 case 뒤의 값이라면 실행문을 실행한다.
        - if문과 다르게 1<변수 처럼 조건문을 사용할 수 없다.
        - case 맨 뒤에는 꼭 break;를 붙여야 한다. 아니면 case 값1을 실행한 후에, 그 뒤의 모든 case를 조건 확인 없이 실행한다.
- 반복문
    - for
        - for(변수 초기화; 조건; 변수 증감) {실행문;}
        - 조건이 true인동안 실행문을 실행한다.
        - 매 for문 마다 변수 증감 부분이 실행된다.
        - 변수 초기화는 처음 한번만 실행된다.
        - 비워놔도 무방하다.
    - while
        - while(조건문) {실행문;}
        - 조건문이 true인동안 계속해서 실행한다.
    - do {실행문} while(조건문);
        - while문과 같지만, 처음부터 조건이 false라도 최소한 한번은 실행한다.
# 참조 타입
- 참조타입이란
    - 참조타입이란 실제 값이 저장되는 것이 아니라, 값이 저장된 주소를 저장한다.
    - 참조타입에는 배열, 열거, 클래스, 인터페이스가 있다.
- 자바의 메모리 사용
    - 메소드
        - .class파일들을 클래스 로더로 읽는다.
        - 클래스별 코드를 분류해서 저장한다.
    - 힙
        - 객체, 배열이 생성되는 영역이다.
        - 참조되는 변수나 필드가 없는 객체는 쓰래기로 판단해서 쓰래기 객체는 자동으로 삭제한다.
    - JVM 스택 영역
        - 스레드마다 존재한다.
        - 스레드가 시작할 때 할당된다.
        - 메소드 호출을 할 때에 JVM 스택 안에 Frame을 추가한다.
        - 메소드 종료를 할 때 해당 Frame을 삭제한다.
- 연산자
    - 참조타입에서 ==은 참조하는 객체가 같은지 비교한다.
- null, NullPointerException
    - heap 영역의 변수를 참조하지 않으면 null값을 갖는다.
    - 값이 null인 참조변수를 쓰면 NullPointerException이 발생한다.
- String
    - 문자열을 저장하는 타입이다.
    - 같은 문자열을 string에 넣으면 같은 객체를 바라본다.
    - 하지만 new 연산으로 새로운 객체를 생성했다면 다른 객체를 바라본다.
    - .equals() 메소드
        - 문자열 내용 그 자체를 비교해주는 메소드
        - 문자열1.equals(문자열2)처럼 사용할 수 있다.
- 배열
    - 타입 변수[]; 처럼 사용할 수 있다.
    - 초기화를 할 때엔 new 연산자를 이용한다.
    - new 타입[] {값1,값2}처럼 초기화 할 수 있다.
        - 이 방식을 사용하면 값의 개수만큼 배열의 크기가 정해진다.
    - new 타입[배열 크기] 처럼 선언할 수 있다.
        - 이 때에는 각 타입마다의 초기값이 들어간다.
    - length
        - 배열.length를 하면 배열의 개수를 반환한다.
    - 다차원 배열
        - 타입 변수[][] = new 타입[행][열] 처럼 사용할 수 있다.
    - 배열 복사
        1. for문 으로 일일이 복사
        2. System.arraycopy 메소드 호출
        3. 얕은 복사
        4. 깊은 복사
    - 배열과 for문
        - for(타입 변수:배열) {
            실행문
        }
        - 위처럼 사용하면 for문 마다 배열의 각 요소를 꺼내서 변수에 넣는다.
- String[] args
    - 우리가 항상 자바 main 함수를 만들 때 보였던 String[] args란 cmd에서 자바를 실행할 때에 java 클래스.class였는데, 그 뒤에 값1, 값2를 해 주면 args 배열에 값을 넣을 수 있다.
- 열거 타입
    - enum 이름 {값1,값2...};
    - 상수중에 없는 값이 들어가려 하면 오류가 난다.
    - name()
        - name()은 열거 객체의 문자열을 반환
    - ordinal()
        - ordinal() 은 인덱스를 반환
    - compareTo()
        - 열거 객체를 비교해서 차이를 반환
    - values()
        - 모든 객체를 배열로 반환
# OOP
- OOP란
    - Object Oriented Programming의 약자로, 객체를 만들어서 그걸 조립해서 프로그램을 만드는 방법이다.
- 객체
    - 메소드
        - 객체에서의 동작
    - 필드
        - 객체에서의 속성
- 클래스
    - 객체를 만드는 설계도
    - API 클래스
    - main 메소드 제공
    - 구성
        - 필드
            - 변수와 비슷하지만 차이가 있다.
            - 메소드 실행 종료시 없어지는 변수와 달리 필드는 객체가 소멸될 때 없어진다.
        - 생성자
            - new 연산자로 호출되는 블록
            - 객체 생성할 때 초기화를 한다.
            - 우리가 선언해 주지 않아도 자동으로 생성됨
            - 클래스(매개변수) {객체 초기화}
            - 리턴 타입이 없음
            - 매개변수는 있어도 되고 없어도 됨
            - 생성자 오버로딩
                - 한 객체에 여러 생성자를 선언할 수 있도록 해줌
        - 메서드
            - 객체의 동작 부분
            - 리턴타입 메소드이름() {실행문}
            - 중괄호의 이름 = 메소드 이름
            - 외부에서 매개값을 입력받고, 반환 값을 줄 수 있다.
            - return 이후의 코드는 실행되지 않음
            - 매개변수의 개수를 모르면 배열타입으로 가능
            - 매개변수의 개수를 모를 때 ...을 통해 더 쉽게 사용할 수 있다.
            - 객체 외부와 내부의 호출이 다르다.
            - 한 클래스 안에 같은 이름의 메소드를 여러개 선언할 수 있다.
    - 이름 규칙
        - 하나 이상의 문자로 구성
        - $, _를 제외한 특수문자 불가능
        - 예약어 사용 불가
        - 첫글자 대문자
- 인스턴스
    - 클래스로 만들어진 객체
- 특징
    - 캡슐화
        - 필드와 메소드를 비슷한 것 끼리 묶은 것
        - 묶여진 각각의 필드와 메소드를 외부에서 사용하지 못하도록 한다.
    - 상속
        - 상위 객체의 필드와 메소드를 상속받은 객체에서도 사용할 수 있도록 하는 것
    - 다형성
        - 같은 타입이라도 실행결과가 다양한 객체를 이용할 수 있는 성질
- 오버로딩, 오버라이딩
    - 오버로딩
        - 함수 이름이 같아도 매개변수가 다르면 함수를 생성할 수 있다.
        - 호출할 때 매개변수가 맞는 함수가 실행된다.
    - 오버라이딩
        - 하위 클래스에서 상위 클래스의 함수를 바꾸는 것(재정의)
